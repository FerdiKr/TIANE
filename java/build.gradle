import java.nio.file.Files
import java.nio.file.Paths

plugins {
    // Apply the java-library plugin to add support for Java Library
    id 'java-library'
}

configurations {
    shade
    compile.extendsFrom shade
}

sourceSets {
    main.java.srcDirs = ['src/java']
    main.resources.srcDirs = ['src/resources']

    test.java.srcDirs = []
    test.resources.srcDirs = []

    headers.java.srcDirs = ['src/headers']
    headers.resources.srcDirs = []

    c.java.srcDirs = ['src/c']
    c.resources.srcDirs = []
}

final ConfigObject cfg = file('build.properties').withReader { def p = new Properties(); p.load(it); return (new ConfigSlurper().parse(p)) }

repositories {
    mavenCentral()
}

dependencies {

}

compileJava {
    outputs.files sourceSets.headers.java

    options.compilerArgs += ['-h', sourceSets.headers.java.srcDirs.iterator().next().toPath().toAbsolutePath().normalize().toString()]
}

jar {
    archivesBaseName = 'jiane'

    configurations.shade.each { dep -> from(project.zipTree(dep)) { exclude 'META-INF', 'META-INF/**' } }
}

task compileGcc {
    dependsOn compileJava

    inputs.files sourceSets.headers.java
    inputs.files sourceSets.c.java

    outputs.files fileTree('build/gcc/compile')

    doLast {
        boolean failed = false

        file('build/gcc/compile').mkdirs()

        sourceSets.c.java.srcDirs.stream().map{f -> f.toPath()}.forEach{ppath -> Files.walk(ppath).filter{pp -> Files.isRegularFile(pp)}.filter{pp -> pp.getFileName().toString().matches('^.*?\\.c(c|pp)?$')}.forEach{pp ->
            StringBuilder args = new StringBuilder(cfg.gccExecutable).append(' -fPIC')
            java.nio.file.Path parentPath = file('build/gcc/compile').toPath().resolve(ppath.relativize(pp)).getParent()
            Files.createDirectories(parentPath)
            args.append(' -o').append(parentPath.resolve(pp.getFileName().toString().substring(0, pp.getFileName().toString().lastIndexOf('.')) + '.o').toAbsolutePath().normalize().toString())
            args.append(' -c ').append(pp.toAbsolutePath().normalize().toString())

            println(args)
            Process process = Runtime.getRuntime().exec(args.toString())
            process.inputStream.newReader().eachLine { line -> System.out.println(line) }
            process.errorStream.newReader().eachLine { line -> System.err.println(line) }
            if (process.waitFor() != 0) {
                failed = true
                println()
            }
        }}

        if (failed)
            throw new IllegalThreadStateException('GCC returned an error code')
    }
}

task linkGcc {
    dependsOn compileGcc

    inputs.files fileTree('build/gcc/compile')

    outputs.files fileTree('build/gcc/shared')

    doLast {
        file('build/gcc/shared').mkdirs()

        StringBuilder headers = new StringBuilder()
        sourceSets.headers.java.iterator().forEachRemaining{f -> headers.append(' -I').append(f.toPath().toAbsolutePath().normalize().toString())}
        if (System.properties.'java.home' == null)
            throw new IllegalStateException('java.home is not set.')
        java.nio.file.Path javaHome = Paths.get(System.properties.'java.home'.toString())
        if (javaHome.getFileName().toString().equalsIgnoreCase('jre'))
            javaHome = javaHome.getParent()
        if (!Files.exists(javaHome) || !Files.isDirectory(javaHome))
            throw new IllegalStateException('java.home was not found: \'' + javaHome.toAbsolutePath().normalize().toString() + '\'')
        Files.walk(javaHome.resolve('include')).filter{p-> Files.isDirectory(p)}.forEach{p -> headers.append(' -I').append(p.toAbsolutePath().normalize().toString())}
        (cfg.headers as String).split(':').iterator().forEachRemaining{s -> if (!s.isEmpty()) headers.append(' -I').append(s)}
        String headerArgs = headers.toString()

        StringBuilder args = new StringBuilder(cfg.gccExecutable).append(' -fPIC -shared').append(headerArgs).append(' -o').append(file('build/gcc/shared/jiane.so').toPath().toAbsolutePath().normalize().toString())

        boolean hasInput = false
        Files.walk(file('build/gcc/compile').toPath()).filter{ pp -> Files.isRegularFile(pp) && pp.getFileName().toString().endsWith('.o') }.forEach{ p ->
            args.append(' ').append(p.toAbsolutePath().normalize().toString())
            hasInput = true
        }

        if (hasInput) {
            println(args)
            Process process = Runtime.getRuntime().exec(args.toString())
            process.inputStream.newReader().eachLine { line -> System.out.println(line) }
            process.errorStream.newReader().eachLine { line -> System.err.println(line) }
            if (process.waitFor() != 0) {
                throw new IllegalStateException('The linker returned an error code')
            }
        }
    }
}

build {

    dependsOn linkGcc

    doLast {
        Files.deleteIfExists(file('jiane.so').toPath())
        Files.deleteIfExists(file('jiane.jar').toPath())

        if (Files.exists(file('build/gcc/shared/jiane.so').toPath()))
            Files.copy(file('build/gcc/shared/jiane.so').toPath(), file('jiane.so').toPath())
        if (Files.exists(file('build/libs/jiane.jar').toPath()))
            Files.copy(file('build/libs/jiane.jar').toPath(), file('jiane.jar').toPath())
    }
}