import java.nio.file.Files
import java.nio.file.Paths

plugins {
    // Apply the java-library plugin to add support for Java Library
    id 'java-library'
}

configurations {
    shade
    compile.extendsFrom shade
}

sourceSets {
    main.java.srcDirs = ['src/java']
    main.resources.srcDirs = ['src/resources']

    test.java.srcDirs = []
    test.resources.srcDirs = []

    headers.java.srcDirs = []
    headers.resources.srcDirs = ['src/headers']

    c.java.srcDirs = []
    c.resources.srcDirs = ['src/c']
}

final ConfigObject cfg = file('build.properties').withReader { def p = new Properties(); p.load(it); return (new ConfigSlurper().parse(p)) }

repositories {
    mavenCentral()
}

dependencies {

}

compileJava {
    outputs.files sourceSets.headers.resources

    options.compilerArgs += ['-h', sourceSets.headers.resources.srcDirs.iterator().next().toPath().resolve('java').toAbsolutePath().normalize().toString()]

    doFirst {
        sourceSets.headers.resources.srcDirs.iterator().forEachRemaining{f -> if (Files.exists(f.toPath().resolve('java')))
        {}//Files.walk(f.toPath().resolve('java')).filter{p -> Files.isRegularFile(p) && p.getFileName().toString().endsWith(".h")}.forEach{p -> Files.delete(p)}
        else
            Files.createDirectories(f.toPath().resolve('java'))
        }
    }
}

jar {
    archivesBaseName = 'jiane'

    configurations.shade.each { dep -> from(project.zipTree(dep)) { exclude 'META-INF', 'META-INF/**' } }

    if (!cfg.mainClass.isEmpty()) {
        manifest {
            attributes 'Main-Class': cfg.mainClass
        }
    }
}

task setPythonVersion {

    outputs.upToDateWhen { false }

    doFirst {
        Files.write(file('src/resources/tiane/java/COMPILED_PYTHON').toPath(), Collections.singletonList(cfg.pythonLibrary))
    }
}
processResources.dependsOn setPythonVersion

task compileGcc {
    dependsOn compileJava

    inputs.files sourceSets.headers.resources
    inputs.files sourceSets.c.resources

    outputs.files fileTree('build/gcc/compile')

    doLast {
        boolean failed = false

        file('build/gcc/compile').mkdirs()

        String headerArgs = getHeaders(sourceSets.headers, cfg.headers)

        sourceSets.c.resources.srcDirs.stream().map{f -> f.toPath()}.forEach{ppath -> Files.walk(ppath).filter{pp -> Files.isRegularFile(pp)}.filter{pp -> pp.getFileName().toString().matches('^.*?\\.c(c|pp)?$')}.forEach{pp ->
            StringBuilder args = new StringBuilder(cfg.gccExecutable).append(' -fPIC').append(headerArgs)
            java.nio.file.Path parentPath = file('build/gcc/compile').toPath().resolve(ppath.relativize(pp)).getParent()
            Files.createDirectories(parentPath)
            args.append(' -o').append(parentPath.resolve(pp.getFileName().toString().substring(0, pp.getFileName().toString().lastIndexOf('.')) + '.o').toAbsolutePath().normalize().toString())
            args.append(' -c ').append(pp.toAbsolutePath().normalize().toString())

            //println(args)
            Process process = Runtime.getRuntime().exec(args.toString())
            process.inputStream.newReader().eachLine { line -> System.out.println(line) }
            process.errorStream.newReader().eachLine { line -> System.err.println(line) }
            if (process.waitFor() != 0) {
                failed = true
                println()
            }
        }}

        if (failed)
            throw new IllegalThreadStateException('GCC returned an error code')
    }
}

task linkGcc {
    dependsOn compileGcc

    inputs.files fileTree('build/gcc/compile')

    outputs.files fileTree('build/gcc/shared')

    doLast {
        file('build/gcc/shared').mkdirs()

        String headerArgs = getHeaders(sourceSets.headers, cfg.headers)

        StringBuilder args = new StringBuilder(cfg.gccExecutable).append(' -fPIC -shared').append(headerArgs).append(' -o').append(file('build/gcc/shared/jiane.so').toPath().toAbsolutePath().normalize().toString())

        boolean hasInput = false
        Files.walk(file('build/gcc/compile').toPath()).filter{ pp -> Files.isRegularFile(pp) && pp.getFileName().toString().endsWith('.o') }.forEach{ p ->
            args.append(' ').append(p.toAbsolutePath().normalize().toString())
            hasInput = true
        }

        (cfg.libraryPath as String).split(':').iterator().forEachRemaining{s -> if (!s.isEmpty()) args.append(' -Wl,-L').append(s)}

        args.append(' -Wl,-l').append(cfg.pythonLibrary)

        cfg.libraries.split(':').iterator().forEachRemaining{s -> if (!s.isEmpty()) args.append(' -Wl,-l').append(s)}


        args.append(' -Wl,-no-undefined')

        if (hasInput) {
            //println(args)
            Process process = Runtime.getRuntime().exec(args.toString())
            process.inputStream.newReader().eachLine { line -> System.out.println(line) }
            process.errorStream.newReader().eachLine { line -> System.err.println(line) }
            if (process.waitFor() != 0) {
                throw new IllegalStateException('The linker returned an error code')
            }
        }
    }
}

build {

    dependsOn linkGcc

    outputs.upToDateWhen { false }

    doLast {
        Files.deleteIfExists(file('.').toPath().resolve("../server/jiane.so"))
        Files.deleteIfExists(file('.').toPath().resolve("../server/jiane.jar"))

        if (Files.exists(file('build/gcc/shared/jiane.so').toPath()))
            Files.copy(file('build/gcc/shared/jiane.so').toPath(), file('.').toPath().resolve("../server/jiane.so"))
        if (Files.exists(file('build/libs/jiane.jar').toPath()))
            Files.copy(file('build/libs/jiane.jar').toPath(), file('.').toPath().resolve("../server/jiane.jar"))
    }
}

private static String getHeaders(SourceSet srcHeaders, String additionalHeaders) {
    StringBuilder headers = new StringBuilder()
    srcHeaders.resources.srcDirs.iterator().forEachRemaining{f -> Files.walk(f.toPath()).filter{p -> Files.isDirectory(p)}.forEach{p -> headers.append(' -I').append(p.toAbsolutePath().normalize().toString())}}
    if (System.properties.'java.home' == null)
        throw new IllegalStateException('java.home is not set.')
    java.nio.file.Path javaHome = Paths.get(System.properties.'java.home'.toString())
    if (javaHome.getFileName().toString().equalsIgnoreCase('jre'))
        javaHome = javaHome.getParent()
    if (!Files.exists(javaHome) || !Files.isDirectory(javaHome))
        throw new IllegalStateException('java.home was not found: \'' + javaHome.toAbsolutePath().normalize().toString() + '\'')
    Files.walk(javaHome.resolve('include')).filter{p-> Files.isDirectory(p)}.forEach{p -> headers.append(' -I').append(p.toAbsolutePath().normalize().toString())}
    additionalHeaders.split(':').iterator().forEachRemaining{s -> if (!s.isEmpty()) headers.append(' -I').append(s)}
    return headers.toString()
}